{% extends "layout.html" %}

{% block title %}
{% endblock %}

{% block main %}
<!-- Delete Feed Modal -->
<div class="modal fade" id="deleteFeedModal" aria-hidden="true" tabindex="-1">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title">Delete Feed...</h5>
				<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
			</div>
			<div class="modal-body">
				<div class="mb-3">
					<label for="selectFeed" class="form-label">Feed to delete</label>
					<select class="form-select form-select-lg form-control" id="selectFeed" aria-describedby="deleteHelp">
					</select>
					<div id="deleteHelp" class="form-text">Choose the feed to delete.</div>
				</div>
			</div>
			<div class="modal-footer">
				<button type="button" id="btnDeleteFeedCancel" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
				<button type="button" id="btnDeleteFeed" class="btn btn-primary">Delete Feed</button>
			</div>
		</div>
	</div>
</div>
<!-- Add Feed Modal -->
<div class="modal fade" id="addFeedModal" aria-hidden="true" tabindex="-1">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title">Add Feed...</h5>
				<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
			</div>
			<div class="modal-body">
				<div class="mb-3 position-relative">
					<label for="inputFeed" class="form-label">Feed address</label>
					<input type="text" class="form-control" id="inputFeed" aria-describedby="feedHelp" required>
                    <div id="add_feed_feedback" class="invalid-feedback">
                        Invalid feed address.
                    </div>
					<div id="feedHelp" class="form-text">Input the address of the feed you want to follow.</div>
				</div>
			</div>
			<div class="modal-footer">
				<button type="button" id="btnAddFeedCancel" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
				<button type="button" id="btnAddFeed" class="btn btn-primary">Add Feed</button>
			</div>
		</div>
	</div>
</div>
<!-- Change Password Modal -->
<div class="modal fade" id="changePasswordModal" aria-hidden="true" tabindex="-1">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title">Change Password</h5>
				<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
			</div>
			<div class="modal-body">
				<div class="mb-3 position-relative">
					<input autocomplete="off" autofocus class="form-control mx-auto w-auto" required id="current_password" placeholder="Current Password" type="password">
                    <div class="invalid-feedback">
                        Incorrect password.
                    </div>
				</div>
				<div class="mb-3">
					<input autocomplete="off" class="form-control mx-auto w-auto" required id="new_password" placeholder="New Password" type="password">
				</div>
				<div class="mb-3 position-relative">
					<input class="form-control mx-auto w-auto" id="confirm_password" required placeholder="Confirm New Password" type="password">
                    <div id="new_password_feedback" class="invalid-feedback">
                        New passwords do not match.
                    </div>
				</div>
			</div>
			<div class="modal-footer">
				<button type="button" id="btnChangePasswordCancel" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
				<button type="button" id="btnChangePassword" class="btn btn-primary">Change Password</button>
			</div>
		</div>
	</div>
</div>
<!-- Start content -->
    <div class="container-fluid position-relative z-1">
        <div class="row  align-items-start">
            <div class="col col-2 ">
                <div id="feeds" class="feeds container-fluid">
                    <div class="mb-3">
                        <label for="active_feed" class="form-label">Feed</label>
                        <select class="form-select form-control" id="active_feed" aria-describedby="activeFeedHelp">
                        </select>
                        <div id="activeFeedHelp" class="form-text">Choose the feed to display.</div>
                    </div>
                </div>
            </div>
            <div class="col col-10  position-relative translate-bottom">
				<div class="mb-3 ">
					<div class="">
					<div class="row align-items-start" id="articles_header">
					<div class="col col-md-auto"><label for="show_type" class="form-label">Show: </label></div>
					<div class="col col-md-auto"><select id="show_type" class="form-control">
						<option value="0">Unread</option>
						<option value="1">Read</option>
						<option value="2">All</option>
					</select>
				</div>
				<div class="col col-md-auto  position-relative translate-bottom"><a id="mark_feed_read" class="btn btn-primary disabled notactive" role="button" data-bs-toggle="button" aria-disabled="true">Mark Read</a></div>
				</div>
				</div>
				</div>
                <div id="articles" class="articles container-fluid position-relative">
                    <p id="noarticles" class="text-center fs-6 fw-normal lh-base invisible d-none" aria-hidden="true">No articles to show.</p>
                    <div id="status_spinner" class="position-relative top-50 start-50 translate-middle z-3 d-none">
                        <div class="spinner-border" role="status">
                          <span class="visually-hidden">Loading...</span>
                        </div>
                      </div>
                      <div class="accordion z-1" id="accordion_articles">
                      </div>
                </div>
            </div>
        </div>
    </div>
	<div class="toast-container position-fixed bottom-0 end-0 p-3">
		<div id="liveToast" class="toast align-items-center" role="alert" aria-live="assertive" aria-atomic="true">
			<div class="d-flex">
			  <div class="toast-body">
				Hello, world! This is a toast message.
			  </div>
			  <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
			</div>
		  </div>
		</div>
    <script>
        class HttpError extends Error {
            constructor(code, message, options) {
                super(message, options);
                this.code = code;
            }
        };


        class BadRequestError extends HttpError {
            constructor(message, options = {}) {
                super(400, message, options);
                this.name = 'BadRequestError';
            }
        };

        class InternalServerError extends HttpError {
            constructor(message, options = {}) {
                super(500, message, options);
                this.name = 'InternalServerError';
            }
        };

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        jQuery.fn.visible = function() {
            return this.css('visibility', 'visible');
        };

        jQuery.fn.invisible = function() {
            return this.css('visibility', 'hidden');
        };

        let timer = null,
            visible_feed = undefined,
            updating_articles = false,
            first_run = true,
            fetch_timeout = 60000,
            show_type = 0,
            open_article = null,
            offset = 0,
            limit = 20,
            last_count = 0,
            last_scrolltop = 0,
            scrollTimer;

        async function fetch_feeds() {
            return fetch("{{ url_for('feed.fetch_feeds') }}", {
                "method": "POST",
                "headers": {
                    "Content-Type": "application/json"
                },
                signal: AbortSignal.timeout(fetch_timeout),
            });
        }

        async function get_feeds(added_feed) {
            // console.log("get_feeds()::");

            // load the feeds for the current user.
            let result = await fetch_feeds();
            return Promise.resolve(result)
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (Error(data));

                    if (data instanceof Error)
                        throw (data);

                    let html = '';
                    try {
                        data.forEach(entry => {
                            html += '<option value="' + entry.id + '">' + entry.title + '</option>';
                        });
                    } catch (error) {
                        // feed list is empty
                    }
                    $('div#feeds > div > select#active_feed').html(html);
                    return data;
                })
                .then(data => {
                    if ($('select#active_feed option').length > 0) {
                        // select the first feed.
                        let feed_to_show = document.cookie
                            .split("; ")
                            .find((row) => row.startsWith("active_feed="))
                            ?.split("=")[1];
                        if (feed_to_show == undefined && visible_feed !== null)
                            feed_to_show = visible_feed;
                        else if (feed_to_show == undefined)
                            feed_to_show = parseInt($("select#active_feed option:first").val(), 10);

                        $("select#active_feed option[value=" + feed_to_show + "]").attr('selected','selected');
                        $("div#articles_header select#show_type option").removeAttr('selected');
                        $("div#articles_header select#show_type  option[value=0]").attr('selected','selected');
                    }
                    return data;
                })
                .then(data => {
                    // trigger an update of the feed contents.
                    if (added_feed !== undefined)
                        update_feed(added_feed);
                    else
                        update_feeds();
                    return data;
                })
                .then(data => {
                    // change active_feed to trigger get_articles.
                    $('div#feeds select#active_feed').trigger('change');

                    return data;
                })
                .catch(error => {
                    console.log("get_feeds: " + error);
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                })
        };

        function isHTML(str) {
            var doc = new DOMParser().parseFromString(str, "text/html");
            return Array.from(doc.body.childNodes).some(node => node.nodeType === 1);
        }

        function format_articles(data) {
            // console.log("format_articles()::");
            let array_of_data = [];
            if (!Array.isArray(data)) // make sure we can handle a single object as well as an array of data. ;)
                array_of_data = [data];
            else
                array_of_data = data;

            // format the articles for display.
            // create date objects for six days ago, and midnight. this will change how we format the published date.
            let date = new Date(Date.now());
            let six_days_ago = new Date(date.getTime() - (6 * 24 * 60 * 60 * 1000));
            six_days_ago.setHours(0, 0, 0, 0);
            let midnight = new Date(date.getTime());
            midnight.setHours(0, 0, 0, 0);
            // using 'Intl.DateTimeFormat' provides an easier way to format the published date. 'navigator.language' should make the format recogniseable to the user i.e. US, UK, FR...
            // with a fallback to en-US if unsupported.
            const long_formatter = new Intl.DateTimeFormat([navigator.language, "en-US"], {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            const medium_formatter = new Intl.DateTimeFormat([navigator.language, "en-US"], {
                weekday: "short",
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            const short_formatter = new Intl.DateTimeFormat([navigator.language, "en-US"], {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });

            let html = '';
            for (let i = 0; i < array_of_data.length; i++) {
                let entry = array_of_data[i];
                // create a string representation of the published date depending on whether it was today, within the last 7 days, or older.
                let date_now = new Date();
                let published = new Date(Date.parse(entry.published));
                let published_string = '';
                if (published.getTime() < six_days_ago.getTime() || published.getTime() > date_now.getTime())
                    published_string = long_formatter.format(published); // older than 7 days
                else if (published.getTime() < midnight.getTime())
                    published_string = medium_formatter.format(published); // within the last 7 days
                else
                    published_string = short_formatter.format(published); // today

                // the newlines and tabs aren't necessary, but make the generated content easier to read.
                html += '\n\t\t\t\t\t\t<div class="accordion-item container-fluid p-0 b-0" id="a' + entry.id + '" data-published-date="' + published.getTime() + '" data-article-id="' + entry.id + '" data-is-read="' + entry.is_read + '">' +
                    '\n\t\t\t\t\t\t\t<h2 class="accordion-header container-fluid flex-nowrap p-0 b-0">';

                html += '\n\t\t\t\t\t\t\t\t<button class="accordion-button collapsed p-3" type="button" id="b' + entry.id + '" data-bs-toggle="collapse"' +
                    ' data-bs-target="#collapse' + entry.id + '" aria-expanded="false" aria-controls="collapse' + entry.id + '">' +
                    '\n\t\t\t\t\t\t\t\t\t<span class="accordion-title container-fluid flex-nowrap lh-base align-bottom p-0 b-0">\n\t\t\t\t\t\t\t\t\t\t<span class="row flex-nowrap lh-base overflow-hidden">\n\t\t\t\t\t\t\t\t\t\t\t<span class="col col-9 col-lg text-truncate text-nowrap lh-base align-middle" data-bs-toggle="tooltip" data-bs-original-title="' + entry.title + '">' +
                    entry.title + '</span>\n\t\t\t\t\t\t\t\t\t\t\t<span id="p' + entry.id + '" class="col col-sm col-sm-auto align-items-end text-nowrap overflow-hidden lh-base align-bottom" data-bs-toggle="tooltip" data-bs-title="' + published_string + '">' + published_string + '</span>\n\t\t\t\t\t\t\t\t\t\t\t<span class="col col-sm col-sm-auto align-items-end text-nowrap overflow-hidden lh-base align-bottom">\n\t\t\t\t\t\t\t\t\t\t\t\t<span id="s' + entry.id + '" class="badge rounded-pill">';

                if (entry.is_read === 1) {
                    html += '<i class="bi bi-envelope-open text-secondary fs-6 fw-normal" data-bs-toggle="tooltip" data-bs-title="Read"></i>';
                }
                else {
                    html += '<i class="bi bi-envelope text-primary fs-6 fw-bolder" data-bs-toggle="tooltip" data-bs-title="Unread"></i>';
                }

                html += '</span>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t</button>' +
                    '\n\t\t\t\t\t\t\t</h2>' +
                    '\n\t\t\t\t\t\t\t<div id="collapse' + entry.id + '" class="accordion-collapse collapse align-top" data-bs-parent="#accordion_articles">' +
                    '\n\t\t\t\t\t\t\t\t<div class="accordion-body container-fluid p-3 b-0">' +
                    '\n\t\t\t\t\t\t\t\t\t<div class="row align-items-start align-top">\n\t\t\t\t\t\t\t\t\t\t<div class="col col-9-auto mh-100 align-items-top align-top">' +
                    '\n\t\t\t\t\t\t\t\t\t\t\t<div class="row clearfix">' +
                    '\n\t\t\t\t\t\t\t\t\t\t\t\t<div class="col align-self-start text-justify">' + (!isHTML(entry.summary) ? '<p>' + entry.summary + '</p>' : entry.summary) + '</div>' +
                    '\n\t\t\t\t\t\t\t\t\t\t\t</div>' +
                    '\n\t\t\t\t\t\t\t\t\t\t\t<div class="row clearfix">' +
                    '\n\t\t\t\t\t\t\t\t\t\t\t\t<p class="more col align-self-end pt-auto mb-0"><a href="' + entry.link + '" class="link-primary" target="_blank" rel="noopener noreferrer">Read more...</a></p>' +
                    '\n\t\t\t\t\t\t\t\t\t\t\t</div>' +
                    '\n\t\t\t\t\t\t\t\t\t\t</div>';
                if (entry.thumb_url !== '') {
                    html += '\n\t\t\t\t\t\t\t\t\t\t<div class="col col-3 align-top"><a href="' + entry.link + '" class="link-primary" target="_blank" rel="noopener noreferrer"><img src="{{ url_for('static', filename='blank_1x1.png') }}" data-src="' + entry.thumb_url + '" class="img-fluid img-thumbnail" loading="lazy" height="' + entry.thumb_height + '" width="' + entry.thumb_width + '" alt="' + entry.title + '"></a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>';
                } else {
                    // no image
                     html += '\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>';
                }
                html += '\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>';
            };
            return html;
        }

        async function fetch_articles(a_limit, a_offset, article_ids) {
            if (a_limit === undefined)
                a_limit = 20;
            if (a_offset === undefined)
                a_offset = 0;
            if (article_ids === undefined || article_ids === [])
                article_ids = '';
            // console.log("fetch_articles()::");
            // fetch limit articles from the server starting at offset.
            // if article_ids is supplied, we ignore limit and offset and fetch those articles.
            return fetch("{{ url_for('article.fetch_articles') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": JSON.stringify({
                        'feed_id': visible_feed,
                        'show_type': show_type,
                        'limit': a_limit,
                        'offset': a_offset,
                        'article_ids': article_ids,
                    }),
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .catch(error => {
                    console.log("fetch_articles: " + error);
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                    return error;
                });
        }

        function initialiseTooltips() {
            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl, {
                html: true // <- this should do the trick!
            }));
        }

        function hideTooltips() {
            $(".tooltip").hide().remove();

        }

        function enhance_accordion() {
            // console.log("enhance_accordion()::");
            hideTooltips();

            // remove event handlers so that we don't add them more than once.
            $("div#articles iv#accordion_articles div[id^='a'].accordion-item").off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');

            // add event handlers to each collapsible
            $("div#articles div#accordion_articles div[id^='a'].accordion-item").on('show.bs.collapse', load_image_and_highlight_article).on('shown.bs.collapse', mark_article_read_event).on('hidden.bs.collapse', hide_article_event);


            initialiseTooltips();
        }

        function toggleMarkFeedReadButton() {
            // toggle 'mark feed read' button (are there 'accordion-item's with data-is-read set to 0)
            if ($("div#articles div#accordion_articles div[id^='a'].accordion-item").filter('[data-is-read="0"]').length > 0)
                $('div#articles_header a#mark_feed_read').removeClass('disabled notactive').removeAttr('aria-disabled');
            else
                $('div#articles_header a#mark_feed_read').addClass('disabled notactive').attr('aria-disabled', 'true');

            // hide or show the accordion articles/noarticles as suitable.
            if ($("div#articles div#accordion_articles > div[id^='a'].accordion-item > h2.accordion-header > button").length > 0) {
                $('div#articles div#accordion_articles').attr('aria-hidden', 'false').removeClass('invisible d-none').addClass('visible').show();
                $('div#articles p#noarticles').attr('aria-hidden', 'true').removeClass('visible').addClass('invisible d-none').hide();
            }
            else {
                $('div#articles div#accordion_articles').attr('aria-hidden', 'true').removeClass('visible').addClass('invisible d-none').hide();
                $('div#articles p#noarticles').attr('aria-hidden', 'false').removeClass('invisible d-none').addClass('visible').show();
            }

            // decide whether the articles div should be scrollable
            if ($('div#accordion_articles').height() > $('div#articles').height()) {
                $('div#articles').addClass('articles-scroll');
            }
            else {
                $('div#articles').removeClass('articles-scroll');
            }

        }

        async function get_articles() {
            // console.log("get_articles()::");
            // populate the articles div.
            if (visible_feed === null || visible_feed === 0)
                return;

            $('div#articles p#noarticles').attr('aria-hidden', 'true').removeClass('visible').addClass('invisible d-none').hide();
            $('div#articles div#status_spinner').removeClass("d-none invisible").show();
            $('div#articles div#accordion_articles').invisible();

            const result = await fetch_articles();

            return Promise.resolve(result)
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (new TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    hideTooltips();
                    let $div_articles = $("div#articles div#accordion_articles");
                    let $articles = $div_articles.children("div[id^='a'].accordion-item");
                    $articles.off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');
                    $articles.remove();
                    updating_articles = true;
                    last_count = data.length;
                    let html = '';

                    html += format_articles(data);

                    $('div#articles div#status_spinner').addClass("d-none").hide();
                    $div_articles.attr('aria-hidden', 'true').removeClass('visible').addClass('invisible d-none').hide();
                    $div_articles.html(html);
                    $div_articles.attr('aria-hidden', 'false').removeClass('invisible d-none').addClass('visible').show();
                    $div_articles.visible();

                    return data;
                })
                .then(data => {
                    return enhance_accordion();
                })
                .catch(error => {
                    if (error instanceof Promise)
                        console.log("get_articles: %s", error.toString());
                    else
                        console.log("get_articles: " + error);
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                })
                .finally(() => {
                    $('div#articles div#status_spinner').addClass("d-none").hide();
                    updating_articles = false;
                    toggleMarkFeedReadButton();
                    $('div#articles').scrollTop(0);
                });

        };

        /**
         * jQuery.fn.sortElements
         *
         * https://github.com/padolsey-archive/jquery.fn/tree/master/sortElements
         * --------------
         * @param Function comparator:
         *   Exactly the same behaviour as [1,2,3].sort(comparator)
         *
         * @param Function getSortable
         *   A function that should return the element that is
         *   to be sorted. The comparator will run on the
         *   current collection, but you may want the actual
         *   resulting sort to occur on a parent or another
         *   associated element.
         *
         *   E.g. $('td').sortElements(comparator, function(){
         *      return this.parentNode;
         *   })
         *
         *   The <td>'s parent (<tr>) will be sorted instead
         *   of the <td> itself.
         */
        jQuery.fn.sortElements = (function(){

            var sort = [].sort;

            return function(comparator, getSortable) {

                getSortable = getSortable || function(){return this;};

                var placements = this.map(function(){

                    var sortElement = getSortable.call(this),
                        parentNode = sortElement.parentNode,

                        // Since the element itself will change position, we have
                        // to have some way of storing its original position in
                        // the DOM. The easiest way is to have a 'flag' node:
                        nextSibling = parentNode.insertBefore(
                            document.createTextNode(''),
                            sortElement.nextSibling
                        );

                    return function() {

                        if (parentNode === this) {
                            throw new Error(
                                "You can't sort elements if any one is a descendant of another."
                            );
                        }

                        // Insert before flag:
                        parentNode.insertBefore(this, nextSibling);
                        // Remove flag:
                        parentNode.removeChild(nextSibling);

                    };

                });

                return sort.call(this, comparator).each(function(i){
                    placements[i].call(getSortable.call(this));
                });

            };

        })();

        function accordionitem_comparator(a, b) {
            // sort by descending published date.
            let sort_result = $(b).data("published-date") - $(a).data("published-date");
            // if the articles have the same published date sort by descending id instead.
            if (sort_result === 0)
                return $(b).data("article-id") - $(a).data("article-id");
            else
                return sort_result;
        }

        function sort_articles() {
            // console.log("sort_articles()::");
            // doing this in the browser is costly, but only a few articles should actually need sorting.
            hideTooltips();

            let $div_articles = $("div#articles div#accordion_articles div[id^='a'].accordion-item");

            $div_articles.off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');
            $div_articles.sortElements(accordionitem_comparator);
        }

        async function add_new_articles(count, article_ids, updated_articles) {
            // console.log("add_new_articles()::");
            if (count === undefined)
                count = 0;
            if (article_ids === undefined)
                article_ids = [];
            if (updated_articles === undefined)
                updated_articles = [];

            if (count === 0)
                return Promise.resolve(true);

            $('div#articles div#status_spinner').removeClass("d-none").show();
            // reloading the whole accordion is a bit drastic, so we'll just add the new articles at the start and then sort them.
            for(val in updated_articles)
                $("div#a" + val).off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse').remove(); // .hide()

            if (!Array.isArray(article_ids))
                article_ids = [article_ids];
            if (!Array.isArray(updated_articles))
                updated_articles = [updated_articles];
            const result = await fetch_articles(limit, offset, article_ids);
            return Promise.resolve(result)
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (new TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    hideTooltips();
                    $("div#articles div#accordion_articles > div[id^='a'].accordion-item").off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');
                    updating_articles = true;
                    let html = '', articles_added = 0;

                    for (let i = 0; i < data.length; i++) {
                        entry = data[i];
                        if (!$('div#articles div#accordion_articles div#a' + entry.id + '.accordion-item').exists()) {
                            // make sure that it's not a duplicate.
                            html += format_articles(entry);
                            articles_added += 1;
                        }
                    };

                    return html;
                })
                .then((html) => {
                    if (html !== '')
                        $('div#articles div#accordion_articles').attr('aria-hidden', 'true').removeClass('visible').addClass('invisible d-none').hide();
                        $("div#articles div#accordion_articles").prepend(html);

                    return html;
                })
                .then(html => {
                    // only sort if we got new articles.
                    if (html !== '') {
                        sort_articles();
                        $('div#articles div#accordion_articles').attr('aria-hidden', 'false').removeClass('invisible d-none').addClass('visible').show();
                    }
                })
                .then(() => {
                    enhance_accordion();
                })
                .then(() => {
                    offset = 0;
                    last_scrolltop = $('div#articles').scrollTop();
                })
                .catch(error => {
                    if (error instanceof Promise)
                        console.log("add_new_articles: %s", error.toString());
                    else
                        console.log("add_new_articles: " + error);

                    if (error.name ===  'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                })
                .finally(() => {
                    $('div#articles div#status_spinner').addClass("d-none").hide();
                    $('div#articles div#accordion_articles').visible();
                    enhance_accordion();
                    updating_articles = false;
                    toggleMarkFeedReadButton();
                });

        }

        function reposition_article() {
            // console.log("reposition_article()::");
            if (open_article !== null) {
                // make sure the collapse doesn't open out of view
                $('div#articles div#accordion_articles div#a' + open_article).get(0).scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
            }
        }

        async function load_image_and_highlight_article(event) {
            const article_id = $(this).data('article-id');

            let $thumbnail = $(this).children().find('img.img-thumbnail');
            $thumbnail.attr('src', $thumbnail.data('src'));

            $(this).addClass("border-top shadow border-primary");
        }

        async function mark_article_read_event(event) {
            // console.log("mark_article_read_event()::");
            const article_id = $(this).data('article-id');

            open_article = article_id;

            if (parseInt($("div#articles div#accordion_articles div#a" + article_id).data("is-read"), 10) == 1)
                return;

            reposition_article();

            if ($('div#accordion_articles').height() > $('div#articles').height())
                $('div#articles').addClass('articles-scroll');

            const result = await mark_article_read(article_id);

            Promise.resolve(result)
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    return response;
                })
                .then(result => {
                    if (result instanceof Error)
                        throw (result);

                    if (result['status'] === 'success') {
                        $("div#articles div#accordion_articles div#a" + article_id).data("is-read", "1");
                        timer = setTimeout(() => {
                            let $icon = $('div#articles div#accordion_articles div#a' + article_id + '.accordion-item span#s' + article_id + ' i');
                            let old_tooltip = bootstrap.Tooltip.getOrCreateInstance($icon[0]);
                            old_tooltip.setContent({'.tooltip-inner': 'Read'});
                            $icon.removeClass("text-primary bi-envelope fw-bold").addClass("text-secondary bi-envelope-open fw-normal").data("bs-title", "Read");
                        }, 500);
                    }
                })
                .catch(error => {
                    if (error instanceof Promise)
                        console.log("mark_article_read_event: %s", error.toString());
                    else
                        console.log("mark_article_read_event: " + error);

                    const liveToast = document.getElementById('liveToast')
                    const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                    $('.toast-body').html('<p>Error: Unable to mark article read.</p>');
                    toastBootstrap.show();
                });

        };

        function mark_article_read(article_id) {
            // console.log("mark_article_read()::");
            const data = JSON.stringify({
                'feed_id': parseInt(visible_feed, 10),
                'article_id': parseInt(article_id, 10),
            });

            return fetch("{{ url_for('article.mark_article_read') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": data,
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .catch(error => {
                    console.log("mark_article_read: " + error);
                    return error;
                });
        }

        function hide_article_event(event) {
            if (updating_articles === true)
                return;

            // console.log("hide_article_event()::");
            const article_id = $(this).data('article-id');
            let $article = $("div#articles div#accordion_articles div#a" + article_id);

            timer = setTimeout(() => {
                // only hide the article if show_type is unread
                if (parseInt(show_type, 10) == 0 && parseInt($article.data("is-read"), 10) == 1) {
                    hideTooltips();
                    $("div#articles div#accordion_articles div#a" + article_id + ".tooltip").hide().remove();
                    $("div#articles div#accordion_articles div#a" + article_id).off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse').remove();
                    toggleMarkFeedReadButton();
                    last_scrolltop = $('div#articles').scrollTop();
                    if ($('div#articles').isScrolledToBottom() && last_count === limit)
                        $('div#articles').trigger('scroll');
                }
            }, 750);

            $article.removeClass("border-top shadow border-primary");

            if (article_id === open_article)
                open_article = null;

            if ($('div#accordion_articles').height() <= $('div#articles').height())
                $('div#articles').removeClass('articles-scroll');

        };

        $('div#addFeedModal input#inputFeed').on('input', () => {
            $('#inputFeed').removeClass('is-invalid')
        });

        function showAddFeedModal(event) {
            event.preventDefault();
            $('div#addFeedModal').modal('show');
        };

        $("div#addFeedModal").on("hide.bs.modal", function() {
            // blur controls to prevent ARIA errors.
            $('div#addFeedModal input#inputFeed').trigger('blur');
            $('div#addFeedModal button#btnAddFeed').trigger('blur');
            $('div#addFeedModal button#btnAddFeedCancel').trigger('blur');
        });

        $("div#addFeedModal").on("hidden.bs.modal", function() {
            $('div#addFeedModal input#inputFeed').removeClass('is-invalid').val('');
        });

        function clickAddFeed(event) {
            $('div#addFeedModal input#inputFeed').removeClass('is-invalid');
            $('div#articles div#status_spinner').removeClass("d-none invisible").show();
            return fetch("{{ url_for('feed.add_feed') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": JSON.stringify({
                        'feed_url': $('#inputFeed').val(),
                    }),
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    if (data['status'] === 'success') {
                        $('div#addFeedModal input#inputFeed').trigger('blur').removeClass('is-invalid');
                        $('div#addFeedModal button#btnAddFeed').trigger('blur');
                        $('div#addFeedModal button#btnAddFeedCancel').trigger('blur');
                        $('div#addFeedModal').modal('hide');
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Feed added.</p>');
                        toastBootstrap.show();
                        visible_feed = parseInt(data['feed_id'], 10);

                    } else
                        throw (new BadRequestError(data['error_type_message'], { cause: data['error']}));

                    return data;
                })
                .then(data => {
                    if (data['status'] === 'success') {
                        hideTooltips();
                        $("div#articles div#accordion_articles div[id^='a'].accordion-item").off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');
                        get_feeds(parseInt(data['feed_id'], 10));
                    }

                    return data;
                })
                .catch(error => {
                    console.log("clickAddFeed: " + error);
                    if (error instanceof BadRequestError) {
                        if (error.cause === 'feed exists')
                            $('div#addFeedModal div#add_feed_feedback').text('Already subscribed.');
                        else
                            $('div#addFeedModal div#add_feed_feedback').text('Invalid feed address.');
                        $('div#addFeedModal input#inputFeed').addClass('is-invalid');
                    }
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                })
                .finally(()=> {
                    $('div#articles div#status_spinner').addClass("d-none invisible").hide();
                });
        };

        async function showDeleteFeedModal(event) {
            event.preventDefault();
            const result = await fetch_feeds();

            return Promise.resolve(result)
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (TypeError(data));

                    let html = '';
                    data.forEach(entry => {
                        html += '<option value="' + entry.id + '">' + entry.title + '</option>';
                    });
                    $('div#deleteFeedModal select#selectFeed').html(html);

                    return data;
                })
                .then(data => {
                    $('div#deleteFeedModal').modal('show');
                    return data;
                })
                .catch(error => {
                    console.log("showDeleteFeedModal: " + error);
                });
        };

        $("div#deleteFeedModal").on("hide.bs.modal", function() {
            // blur controls to prevent ARIA errors.
            $('div#deleteFeedModal button#btnDeleteFeed').trigger('blur');
            $('div#deleteFeedModal button#btnDeleteFeedCancel').trigger('blur');
        });

        function clickDeleteFeed(event) {
            const feed_id = $('div#deleteFeedModal > select#selectFeed').val();
            return fetch("{{ url_for('feed.delete_feed') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": JSON.stringify({
                        'feed_id': parseInt(feed_id, 10),
                    }),
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    if (data['status'] === 'success') {
                        $('div#deleteFeedModal button#btnDeleteFeed').trigger('blur');
                        $('div#deleteFeedModal button#btnDeleteFeedCancel').trigger('blur');
                        $('div#deleteFeedModal select#selectFeed').trigger('blur').html('');
                        $('div#deleteFeedModal').modal('hide');

                        const liveToast = document.getElementById('liveToast');
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Feed deleted.</p>');
                        toastBootstrap.show();
                    }
                    else
                        throw (new BadRequestError("Bad Request."));
                    return data;
                })
                .then(data => {
                    if (data['status'] === 'success' && feed_id === visible_feed) {
                        visible_feed = null;
                        open_article = null;
                        $("div#articles div#accordion_articles > div[id^='a'].accordion-item").remove();
                        //$('div#articles div#accordion_articles').html('');
                    }
                    return data;
                })
                .then(data => {
                    if (data['status'] === 'success')
                        get_feeds();
                    return data;
                })
                .then(data => {
                    if (data['status'] === 'success') {
                        // clean up the database. deleting the feed and articles will leave empty space.
                        timer = setTimeout(() => {
                            compact_db();
                        }, 750);
                    }
                    return data;
                })
                .catch(error => {
                    console.log("clickDeleteFeed: " + error);

                    const liveToast = document.getElementById('liveToast');
                    const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                    $('.toast-body').html('<p>Error: Unable to delete feed.</p>');
                    toastBootstrap.show();
                });
        };

        async function update_feeds() {
            // console.log("update_feeds()::");
            let update_queue = [];

            $('div#feeds select#active_feed option').each(function() {
                update_queue.push(update_feed($(this).val()));
            });

            return Promise.all(update_queue);
        };

        async function update_feed(feed_id) {
            // console.log("update_feed()::");
            let data = null,
                result = '';

            data = JSON.stringify({
                'feed_id': parseInt(feed_id, 10),
            });

            return fetch("{{ url_for('feed.update_feed') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": data,
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 304) {
                        return {'status': 'unchanged'};
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    if (visible_feed !== undefined && parseInt(feed_id, 10) === parseInt(visible_feed, 10)) {
                        if (data['status'] === 'success' && parseInt(data['count'], 10) > 0) {
                            if (first_run === false)
                                add_new_articles(parseInt(data['count'], 10), data['article_ids'], data['updated_articles']);
                            else {
                                // changeActiveFeed will get articles on first call
                                first_run = false;
                            }
                            const liveToast = document.getElementById('liveToast')
                            const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                            $('.toast-body').html('<p>Feed updated.</p>');
                            toastBootstrap.show();
                        }  else if (data['status'] === 'unchanged') {
                            const liveToast = document.getElementById('liveToast')
                            const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                            $('.toast-body').html('<p>No new articles.</p>');
                            toastBootstrap.show();
                        } else {
                            const liveToast = document.getElementById('liveToast')
                            const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                            $('.toast-body').html('<p>Error: Unable to update articles.</p>');
                            toastBootstrap.show();
                        }

                    }

                    return data;
                })
                .catch(error => {
                    console.log("update_feed: " + error + " feed id: " + feed_id);
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                });
        }

        async function changeActiveFeed(event) {
            // console.log("changeActiveFeed()::");
            if ($('div#feeds select#active_feed:selected').val() === '')
                return;

            let result = await Promise.resolve().then(() => {
                    $('div#articles_header a#mark_feed_read').addClass('disabled notactive').attr('aria-disabled', 'true');
                    hideTooltips();
                    $("div#articles div#accordion_articles div[id^='a'].accordion-item").off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');
                    $("div#articles div#accordion_articles div[id^='a'].accordion-item").remove();
                    toggleMarkFeedReadButton();
                })
                .then(()=> {
                    show_type = parseInt($('div#articles_header select#show_type').val(), 10);
                    new_visible_feed = parseInt($("div#feeds select#active_feed").val(), 10);
                    if (new_visible_feed !== visible_feed)
                        show_type = 0;

                    $show_type = $("div#articles_header select#show_type");
                    $("div#articles_header select#show_type option").removeAttr('selected');
                    $("div#articles_header select#show_type option[value=" + show_type + "]").attr('selected','selected');

                    visible_feed = new_visible_feed;
                    document.cookie = "active_feed=" + visible_feed.toString();
                    $("div#feeds select#active_feed option").removeAttr('selected');
                    $("div#feeds select#active_feed option[value=" + visible_feed + "]").attr('selected','selected').trigger('change.$show_type');
                })
                .then(() => {
                    get_articles();
                })
                .catch(error => {
                    console.log("changeActiveFeed: " + error);
                })
                .finally(() => {
                    open_article = null;
                    offset = 0;
                    last_scrolltop = 0;
                });

        };


        function mark_feed_read(event) {
            event.preventDefault();
            if (show_type === 1)
                return;

            data = JSON.stringify({
                'feed_id': parseInt(visible_feed, 10),
            });
            return fetch("{{ url_for('feed.mark_feed_read') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": data,
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    if (data['status'] === 'success') {
                        if (show_type === 0) {
                            offset = 0;
                            hideTooltips();
                            $("div#articles div#accordion_articles div[id^='a'].accordion-item").off('show.bs.collapse').off('shown.bs.collapse').off('hidden.bs.collapse');
                            $("div#articles div#accordion_articles div[id^='a'].accordion-item").remove();
                        }

                        const liveToast = document.getElementById('liveToast');
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Feed Marked Read.</p>');
                        toastBootstrap.show();
                    }
                    else
                        throw(new BadRequestError("Bad Request."));

                    return data;
                })
                .catch(error => {
                    console.log("mark_feed_read: " + error + "\r\n " + error.cause);

                    const liveToast = document.getElementById('liveToast');
                    const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                    $('.toast-body').html('<p>Error: Unable to mark feed read.</p>');
                    toastBootstrap.show();
                })
                .finally(() => {
                    toggleMarkFeedReadButton();
                })
        };

        function showChangePasswordModal(event) {
            event.preventDefault();
            $('div#changePasswordModal').modal('show');
        };

        $("div#changePasswordModal").on("hide.bs.modal", function() {
            // blur controls to prevent ARIA errors.
            $('div#changePasswordModal button#btnChangePassword').trigger('blur');
            $('div#changePasswordModal button#btnChangePasswordCancel').trigger('blur');
            $('div#changePasswordModal input#current_password').trigger('blur');
            $('div#changePasswordModal input#new_password').trigger('blur');
            $('div#changePasswordModal input#confirm_password').trigger('blur');
        });

        function clickChangePassword(event) {

            const data = JSON.stringify({
                'current_password': $('div#changePasswordModal input#current_password').val(),
                'new_password': $('div#changePasswordModal input#new_password').val(),
                'confirm_password': $('div#changePasswordModal input#confirm_password').val(),
            });
            return fetch("{{ url_for('auth.change_password') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": data,
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 400) {
                        let result = response.json();
                        return result.then((result) => {
                            return new BadRequestError('Bad Request Error', { cause: result['error']});
                        });
                    }

                    if (response.status === 500) {
                        let result = response.text();
                        return result.then((result) => {
                            return new InternalServerError('Internal Server Error', { cause: result});
                        });
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .then(data => {
                    if (data instanceof Promise)
                        throw (TypeError(data));

                    if (data instanceof Error)
                        throw (data);

                    if (data['status'] === 'success') {
                        $('div#changePasswordModal').modal('hide');
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Password changed.</p>');
                        toastBootstrap.show();
                    }
                    else
                        throw (new BadRequestError(data['error_type_message'], { cause: data['error']}));

                    return data;
                })
                .catch(error => {
                    console.log("clickChangePassword: " + error);
                    if (error instanceof BadRequestError) {
                        if (error.cause === 'bad password')
                            $('div#changePasswordModal input#current_password').addClass('is-invalid');
                        else if (error.cause  === 'password mismatch') {
                            $('div#changePasswordModal div#new_password_feedback').text('New passwords do not match.');
                            $('div#changePasswordModal input#new_password').addClass('is-invalid');
                            $('div#changePasswordModal input#confirm_password').addClass('is-invalid');
                        } else if (error.cause  === 'password blank') {
                            $('div#changePasswordModal div#new_password_feedback').text('New passwords cannot be blank.');
                            $('div#changePasswordModal input#new_password').addClass('is-invalid');
                            $('div#changePasswordModal input#confirm_password').addClass('is-invalid');
                        }
                    }
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                });
        }

        $('div#changePasswordModal input#current_password').on('input', () => {
            $('div#changePasswordModal input#current_password').removeClass('is-invalid');
        });

        $('div#changePasswordModal input#new_password').on('input', () => {
            $('div#changePasswordModal input#new_password').removeClass('is-invalid');
            $('div#changePasswordModal input#confirm_password').removeClass('is-invalid');
        });

        $('div#changePasswordModal input#confirm_password').on('input', () => {
            $('div#changePasswordModal input#confirm_password').removeClass('is-invalid');
            $('div#changePasswordModal input#new_password').removeClass('is-invalid');
        });

        async function compact_db() {
            return fetch("{{ url_for('util.compact_db') }}", {
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body": "",
                    signal: AbortSignal.timeout(fetch_timeout),
                })
                .then(response => {
                    if (!response)
                        throw (new TypeError(response));

                    if (response.redirected) {
                        window.location.href = response.url;
                    }

                    if (response.ok) {
                        return response.json();
                    }

                    if (response instanceof Error)
                        throw (response);

                    return response;
                })
                .catch(error => {
                    console.log("compact_db: " + error);
                    if (error.name === 'TimeoutError') {
                        const liveToast = document.getElementById('liveToast')
                        const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                        $('.toast-body').html('<p>Error: Connection timed out.</p>');
                        toastBootstrap.show();
                    }
                });
        }

        $("div#changePasswordModal").on("hidden.bs.modal", function() {
            $('div#changePasswordModal input#current_password').removeClass('is-invalid').val('');
            $('div#changePasswordModal input#new_password').removeClass('is-invalid').val('');
            $('div#changePasswordModal input#confirm_password').removeClass('is-invalid').val('');
        });

        function resizeEvent(event) {
            if (open_article === null)
                return;

            //reposition_article();
        }

        // add an 'isScrolledToBottom' function to the jQuery object. we're only using this in articlesScrollEvent.
        jQuery.fn.isScrolledToBottom = function() {
            // https://medium.com/@jbbpatel94/difference-between-offsetheight-clientheight-and-scrollheight-cfea5c196937
            //const element = this.get(0);
            //return element.scrollHeight - element.scrollTop === element.clientHeight;
            const element = $(this);
            //return element.scrollTop() + element.innerHeight() >=  element[0].scrollHeight * 0.85;
            return element.scrollTop() + element.innerHeight() >=  $('div#articles > div#accordion_articles').height() - 50;
        }

        // add an 'exists' function to the jQuery object.
        jQuery.fn.exists = function() {
            return this.length > 0;
        };

        async function articlesScrollEvent(event) {
            // console.log("articlesScrollEvent()::");
            // if we are scrolling fetch another limit articles and add them to the accordion.

            hideTooltips();

            async function perform_scroll() {
                // console.log("perform_scroll()::");
                if ($('div#articles').isScrolledToBottom() && $('div#articles').scrollTop() >= last_scrolltop && last_count === limit) {
                    $('div#articles div#status_spinner').removeClass("d-none").show();
                    hideTooltips();
                    offset = offset + limit;
                    const result = await fetch_articles(limit, offset);
                    return Promise.resolve(result)
                        .then(response => {
                            if (!response)
                                throw (new TypeError(response));

                            if (response.redirected) {
                                window.location.href = response.url;
                            }

                            if (response.ok) {
                                return response.json();
                            }

                            if (response instanceof Error)
                                throw (response);

                            return response;
                        })
                        .then(data => {
                            if (data instanceof Promise)
                                throw (TypeError(data));

                            last_count = data.length;
                            let html = '';
                            for (let i = 0; i < data.length; i++) {
                                entry = data[i];
                                if (!$('div#articles div#accordion_articles div#a' + entry.id).exists()) // make sure its not a duplicate.
                                    html += format_articles(entry);
                            };
                            return html;
                        })
                        .then(html => {
                            $('div#articles div#accordion_articles').append(html);
                        })
                        .then(() => {
                            $('div#articles div#accordion_articles').attr('aria-hidden', 'true').removeClass('visible').addClass('invisible d-none').hide();
                            sort_articles();
                            $('div#articles div#accordion_articles').attr('aria-hidden', 'false').removeClass('invisible d-none').addClass('visible').show();
                        })
                        .then(() => {
                            enhance_accordion();
                        })
                        .catch(error => {
                            last_count = 0;
                            console.log("articlesScrollEvent: " + error);
                            if (error.name === 'TimeoutError') {
                                const liveToast = document.getElementById('liveToast')
                                const toastBootstrap = bootstrap.Toast.getOrCreateInstance(liveToast);
                                $('.toast-body').html('<p>Error: Connection timed out.</p>');
                                toastBootstrap.show();
                            }
                        })
                        .finally(() => {
                            $('div#articles div#status_spinner').addClass("d-none").hide();
                            updating_articles === false;
                            toggleMarkFeedReadButton();
                        });
                } else if ($('div#articles').scrollTop() === 0 && $('div#articles').scrollTop() <= last_scrolltop && last_count === limit) {

                }

            }

            // Only respond to the last scroll  event we receive...
            clearTimeout(scrollTimer);

            scrollTimer = setTimeout(perform_scroll, 500);

            last_scrolltop = $('div#articles').scrollTop();
        }

        $(document).ready(function() {
            // register event handlers. using jQuery seems to work more reliably in chrome
            $(window).on('resize', resizeEvent);
            $('div#navbar a#add_feed').on('click', showAddFeedModal);
            $('div#navbar a#delete_feed').on('click', showDeleteFeedModal);
            $('div#addFeedModal button#btnAddFeed').on('click', clickAddFeed);
            $('div#deleteFeedModal button#btnDeleteFeed').on('click', clickDeleteFeed);
            $('div#feeds select#active_feed').on('change', changeActiveFeed);
            $('div#articles_header select#show_type').on('change', changeActiveFeed);
            $('div#articles_header a#mark_feed_read').on('click', mark_feed_read);
            $('div#navbar a#change_password').on('click', showChangePasswordModal);
            $('div#changePasswordModal button#btnChangePassword').on('click', clickChangePassword);
            $('div#articles').on('scroll', articlesScrollEvent);

            $('div#articles p#noarticles').attr('aria-hidden', 'true').hide();

            // check for new articles every 20 minutes
            window.setInterval(update_feeds, 1200000);

            // get the party started :D
            get_feeds();
        });
    </script>
<!-- End Content -->
{% endblock %}
